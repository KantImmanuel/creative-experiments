<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STREET BRAWLER</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
canvas { image-rendering: pixelated; display: block; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = 800, H = 500;
canvas.width = W; canvas.height = H;

// Scale canvas to fit window
function resize() {
  const s = Math.min(window.innerWidth / W, window.innerHeight / H);
  canvas.style.width = (W * s) + 'px';
  canvas.style.height = (H * s) + 'px';
}
resize();
window.addEventListener('resize', resize);

// ===== AUDIO =====
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(type) {
  const g = audioCtx.createGain();
  g.connect(audioCtx.destination);
  const o = audioCtx.createOscillator();
  const n = audioCtx.createBiquadFilter();
  n.connect(g);
  
  if (type === 'punch') {
    // Noise burst
    const buf = audioCtx.createBuffer(1, 2000, audioCtx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < 2000; i++) d[i] = (Math.random() * 2 - 1) * (1 - i/2000);
    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    const f = audioCtx.createBiquadFilter();
    f.type = 'lowpass'; f.frequency.value = 800;
    src.connect(f); f.connect(g);
    g.gain.setValueAtTime(0.4, audioCtx.currentTime);
    g.gain.exponentialDecayToValueAtTime?.(0.01, audioCtx.currentTime + 0.1) || g.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
    src.start(); src.stop(audioCtx.currentTime + 0.15);
    return;
  }
  if (type === 'kick') {
    o.connect(g);
    o.frequency.setValueAtTime(150, audioCtx.currentTime);
    o.frequency.linearRampToValueAtTime(40, audioCtx.currentTime + 0.2);
    g.gain.setValueAtTime(0.5, audioCtx.currentTime);
    g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.25);
    o.start(); o.stop(audioCtx.currentTime + 0.25);
    return;
  }
  if (type === 'special') {
    o.type = 'sawtooth'; o.connect(g);
    o.frequency.setValueAtTime(200, audioCtx.currentTime);
    o.frequency.linearRampToValueAtTime(800, audioCtx.currentTime + 0.15);
    o.frequency.linearRampToValueAtTime(100, audioCtx.currentTime + 0.4);
    g.gain.setValueAtTime(0.4, audioCtx.currentTime);
    g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.45);
    o.start(); o.stop(audioCtx.currentTime + 0.45);
    return;
  }
  if (type === 'ko') {
    o.type = 'square'; o.connect(g);
    o.frequency.setValueAtTime(600, audioCtx.currentTime);
    o.frequency.linearRampToValueAtTime(100, audioCtx.currentTime + 0.8);
    g.gain.setValueAtTime(0.5, audioCtx.currentTime);
    g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 1.0);
    o.start(); o.stop(audioCtx.currentTime + 1.0);
    return;
  }
  if (type === 'round') {
    o.type = 'square'; o.connect(g);
    g.gain.setValueAtTime(0.3, audioCtx.currentTime);
    [440, 550, 660].forEach((f, i) => {
      o.frequency.setValueAtTime(f, audioCtx.currentTime + i * 0.15);
    });
    g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
    o.start(); o.stop(audioCtx.currentTime + 0.5);
    return;
  }
  if (type === 'hit') {
    o.type = 'triangle'; o.connect(g);
    o.frequency.setValueAtTime(300, audioCtx.currentTime);
    o.frequency.linearRampToValueAtTime(80, audioCtx.currentTime + 0.1);
    g.gain.setValueAtTime(0.3, audioCtx.currentTime);
    g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.12);
    o.start(); o.stop(audioCtx.currentTime + 0.12);
    return;
  }
  if (type === 'fight') {
    o.type = 'sawtooth'; o.connect(g);
    g.gain.setValueAtTime(0.35, audioCtx.currentTime);
    [330, 440, 550, 660].forEach((f, i) => {
      o.frequency.setValueAtTime(f, audioCtx.currentTime + i * 0.1);
    });
    g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.6);
    o.start(); o.stop(audioCtx.currentTime + 0.6);
  }
}

// ===== INPUT =====
const keys = {};
document.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; e.preventDefault(); });
document.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; e.preventDefault(); });

// ===== GAME STATE =====
let gameState = 'title'; // title, roundIntro, fight, ko, matchEnd
let shakeX = 0, shakeY = 0, shakeTimer = 0;
let roundNum = 1, p1Wins = 0, p2Wins = 0;
let koTimer = 0, roundIntroTimer = 0;
let winner = 0;
let titleBlink = 0;
let p2LastInput = Date.now();
let aiActive = false;
let particles = [];
let comboCounters = [0, 0];
let comboTimers = [0, 0];
let hitSpark = null;

const GROUND = H - 80;
const GRAVITY = 0.6;

// ===== STARS for background =====
const stars = Array.from({length: 80}, () => ({
  x: Math.random() * W, y: Math.random() * (GROUND - 60), s: Math.random() * 2 + 0.5, b: Math.random()
}));

// ===== BUILDINGS =====
const buildings = [];
for (let i = 0; i < 12; i++) {
  const bw = 40 + Math.random() * 60;
  const bh = 80 + Math.random() * 160;
  buildings.push({ x: i * 70 - 10, w: bw, h: bh, color: `hsl(${220 + Math.random()*30}, ${20+Math.random()*20}%, ${8+Math.random()*12}%)`,
    windows: Array.from({length: Math.floor(bh/20)}, (_, r) => Array.from({length: Math.floor(bw/15)}, () => Math.random() > 0.4))
  });
}

// ===== FIGHTER =====
function createFighter(x, color, name, facing) {
  return {
    x, y: GROUND, vx: 0, vy: 0, w: 50, h: 90,
    color, name, facing,
    health: 100, maxHealth: 100,
    state: 'idle', // idle, walk, jump, crouch, punch, kick, special, hitstun, block, down
    stateTimer: 0,
    attackHit: false,
    crouching: false,
    blocking: false,
    specialCooldown: 0,
    projectile: null,
    animFrame: 0,
    flashTimer: 0,
  };
}

let p1, p2;

function resetFighters() {
  p1 = createFighter(200, '#e63946', 'RYU', 1);
  p2 = createFighter(600, '#457b9d', 'KEN', -1);
  particles = [];
  comboCounters = [0, 0];
  comboTimers = [0, 0];
}

function resetMatch() {
  roundNum = 1; p1Wins = 0; p2Wins = 0;
  resetFighters();
}

resetFighters();

// ===== ATTACK DATA =====
const attacks = {
  punch:   { damage: 8,  range: 55, duration: 12, startup: 3, active: 4, recovery: 5,  knockback: 3, hitstun: 12, yOff: -40, h: 15 },
  kick:    { damage: 12, range: 65, duration: 18, startup: 5, active: 5, recovery: 8,  knockback: 6, hitstun: 16, yOff: -20, h: 20 },
  special: { damage: 20, range: 0,  duration: 30, startup: 8, active: 10, recovery: 12, knockback: 12, hitstun: 25, yOff: -45, h: 20, isProjectile: true },
};

function getAttackBox(f, atk) {
  const a = attacks[atk];
  const cx = f.x + f.facing * (f.w/2 + a.range/2);
  return { x: cx - a.range/2, y: f.y + a.yOff - a.h/2, w: a.range, h: a.h };
}

function boxOverlap(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

function fighterBox(f) {
  const h = f.crouching ? 55 : 90;
  return { x: f.x - f.w/2, y: f.y - h, w: f.w, h };
}

// ===== PARTICLES =====
function spawnParticles(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y, vx: (Math.random()-0.5)*8, vy: (Math.random()-0.5)*8 - 2,
      life: 20 + Math.random()*15, maxLife: 35, color, size: 2 + Math.random()*4
    });
  }
}

function spawnHitSpark(x, y) {
  hitSpark = { x, y, timer: 8 };
}

// ===== AI =====
function aiControl(ai, target) {
  const dx = target.x - ai.x;
  const dist = Math.abs(dx);
  const input = { left: false, right: false, jump: false, crouch: false, punch: false, kick: false, special: false };
  
  const t = Date.now() * 0.001;
  const aggression = (Math.sin(t * 0.7) + 1) * 0.5;
  
  if (ai.state === 'hitstun' || ai.state === 'down') return input;
  
  // Face target
  if (dist > 80) {
    if (dx > 0) input.right = true; else input.left = true;
  }
  
  // Attack when close
  if (dist < 70 && ai.state === 'idle') {
    if (Math.random() < 0.08) input.punch = true;
    else if (Math.random() < 0.05) input.kick = true;
  }
  
  // Special from range
  if (dist > 150 && dist < 400 && ai.specialCooldown <= 0 && Math.random() < 0.02 * aggression) {
    input.special = true;
  }
  
  // Jump sometimes
  if (Math.random() < 0.01) input.jump = true;
  
  // Jump over projectiles
  if (target.projectile) {
    const pd = Math.abs(target.projectile.x - ai.x);
    if (pd < 120 && ai.y >= GROUND) input.jump = true;
  }
  
  // Block
  if (target.state === 'punch' || target.state === 'kick') {
    if (dist < 80 && Math.random() < 0.3) {
      input.left = dx > 0; input.right = dx < 0; // walk away = block
    }
  }
  
  return input;
}

// ===== UPDATE FIGHTER =====
function updateFighter(f, input, opponent, idx) {
  f.animFrame++;
  if (f.flashTimer > 0) f.flashTimer--;
  if (f.specialCooldown > 0) f.specialCooldown--;
  if (comboTimers[idx] > 0) { comboTimers[idx]--; if (comboTimers[idx] <= 0) comboCounters[idx] = 0; }
  
  // Auto face opponent
  if (f.state === 'idle' || f.state === 'walk') {
    f.facing = opponent.x > f.x ? 1 : -1;
  }
  
  // State machine
  if (f.state === 'hitstun') {
    f.stateTimer--;
    f.vx *= 0.85;
    if (f.stateTimer <= 0) f.state = 'idle';
  } else if (f.state === 'down') {
    f.stateTimer--;
    if (f.stateTimer <= 0) { f.state = 'idle'; f.y = GROUND; }
  } else if (f.state === 'punch' || f.state === 'kick' || f.state === 'special') {
    f.stateTimer--;
    const a = attacks[f.state];
    const frame = a.duration - f.stateTimer;
    
    // Check hit during active frames
    if (!f.attackHit && frame >= a.startup && frame < a.startup + a.active) {
      if (!a.isProjectile) {
        const atkBox = getAttackBox(f, f.state);
        const defBox = fighterBox(opponent);
        if (boxOverlap(atkBox, defBox)) {
          applyHit(f, opponent, f.state, idx);
        }
      }
    }
    
    if (f.stateTimer <= 0) { f.state = 'idle'; f.crouching = false; }
  } else {
    // Can act
    f.crouching = false;
    const onGround = f.y >= GROUND;
    
    if (input.special && f.specialCooldown <= 0 && onGround) {
      f.state = 'special'; f.stateTimer = attacks.special.duration; f.attackHit = false;
      f.specialCooldown = 60;
      // Fire projectile
      f.projectile = { x: f.x + f.facing * 30, y: f.y - 45, vx: f.facing * 7, life: 80, hit: false };
      playSound('special');
    } else if (input.punch && onGround) {
      f.state = 'punch'; f.stateTimer = attacks.punch.duration; f.attackHit = false;
    } else if (input.kick && onGround) {
      f.state = 'kick'; f.stateTimer = attacks.kick.duration; f.attackHit = false;
    } else if (input.jump && onGround) {
      f.vy = -13; f.y -= 1;
    } else if (input.crouch && onGround) {
      f.crouching = true; f.state = 'idle';
    } else {
      const speed = 4;
      if (input.left) { f.vx = -speed; f.state = 'walk'; }
      else if (input.right) { f.vx = speed; f.state = 'walk'; }
      else { f.state = 'idle'; }
    }
  }
  
  // Physics
  f.vy += GRAVITY;
  f.x += f.vx;
  f.y += f.vy;
  
  if (f.y >= GROUND) { f.y = GROUND; f.vy = 0; }
  if (f.state !== 'hitstun' && f.state !== 'down') f.vx *= 0.8;
  
  // Bounds
  f.x = Math.max(25, Math.min(W - 25, f.x));
  
  // Update projectile
  if (f.projectile) {
    f.projectile.x += f.projectile.vx;
    f.projectile.life--;
    if (f.projectile.life <= 0 || f.projectile.x < -20 || f.projectile.x > W + 20) {
      f.projectile = null;
    } else if (!f.projectile.hit) {
      const pb = { x: f.projectile.x - 15, y: f.projectile.y - 10, w: 30, h: 20 };
      const db = fighterBox(opponent);
      if (boxOverlap(pb, db)) {
        f.projectile.hit = true;
        applyHit(f, opponent, 'special', idx);
        f.projectile = null;
      }
    }
  }
}

function applyHit(attacker, defender, type, attackerIdx) {
  const a = attacks[type];
  attacker.attackHit = true;
  defender.health = Math.max(0, defender.health - a.damage);
  defender.state = 'hitstun';
  defender.stateTimer = a.hitstun;
  defender.vx = attacker.facing * a.knockback;
  defender.vy = type === 'special' ? -4 : (type === 'kick' ? -3 : -1);
  defender.flashTimer = 6;
  
  const defIdx = 1 - attackerIdx;
  comboCounters[attackerIdx]++;
  comboTimers[attackerIdx] = 45;
  
  const hx = (attacker.x + defender.x) / 2;
  const hy = defender.y - 50;
  spawnParticles(hx, hy, '#fff', 6);
  spawnHitSpark(hx, hy);
  
  if (type === 'kick' || type === 'special') {
    shakeTimer = type === 'special' ? 12 : 6;
    playSound(type === 'special' ? 'hit' : 'kick');
  } else {
    playSound('punch');
  }
  
  if (defender.health <= 0) {
    defender.state = 'down';
    defender.stateTimer = 60;
    defender.vy = -8;
    defender.vx = attacker.facing * 8;
  }
}

// ===== DRAW BACKGROUND =====
function drawBackground() {
  // Night sky gradient
  const grad = ctx.createLinearGradient(0, 0, 0, GROUND);
  grad.addColorStop(0, '#0a0a2e');
  grad.addColorStop(0.5, '#1a1a3e');
  grad.addColorStop(1, '#2a1a3e');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, GROUND);
  
  // Moon
  ctx.fillStyle = '#ffe8b0';
  ctx.beginPath();
  ctx.arc(650, 70, 35, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#0a0a2e';
  ctx.beginPath();
  ctx.arc(665, 60, 30, 0, Math.PI * 2);
  ctx.fill();
  
  // Stars
  stars.forEach(s => {
    const b = (Math.sin(Date.now() * 0.002 + s.b * 10) + 1) * 0.5;
    ctx.fillStyle = `rgba(255,255,220,${0.3 + b * 0.7})`;
    ctx.fillRect(s.x, s.y, s.s, s.s);
  });
  
  // Buildings
  buildings.forEach(b => {
    const by = GROUND - b.h;
    ctx.fillStyle = b.color;
    ctx.fillRect(b.x, by, b.w, b.h);
    // Windows
    b.windows.forEach((row, r) => {
      row.forEach((on, c) => {
        if (on) {
          const flicker = Math.random() > 0.01;
          ctx.fillStyle = flicker ? `rgba(255,230,150,${0.5 + Math.random()*0.3})` : '#111';
          ctx.fillRect(b.x + 5 + c * 15, by + 5 + r * 20, 8, 12);
        }
      });
    });
  });
  
  // Ground
  ctx.fillStyle = '#2a2a2a';
  ctx.fillRect(0, GROUND, W, H - GROUND);
  ctx.fillStyle = '#3a3a3a';
  ctx.fillRect(0, GROUND, W, 3);
  
  // Ground lines
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1;
  for (let i = 0; i < W; i += 40) {
    ctx.beginPath();
    ctx.moveTo(i, GROUND + 10);
    ctx.lineTo(i + 20, H);
    ctx.stroke();
  }
}

// ===== DRAW FIGHTER =====
function drawFighter(f) {
  const flash = f.flashTimer > 0 && f.flashTimer % 2 === 0;
  const col = flash ? '#fff' : f.color;
  const h = f.crouching ? 55 : 90;
  const headY = f.y - h;
  
  ctx.save();
  
  if (f.state === 'down') {
    // Lying down
    ctx.fillStyle = col;
    ctx.fillRect(f.x - 40, f.y - 20, 80, 20);
    // Head
    ctx.beginPath();
    ctx.arc(f.x - 35 * f.facing, f.y - 20, 12, 0, Math.PI * 2);
    ctx.fill();
  } else {
    // Body
    ctx.fillStyle = col;
    const bodyW = 30, bodyH = h * 0.5;
    ctx.fillRect(f.x - bodyW/2, f.y - h + 20, bodyW, bodyH);
    
    // Head
    ctx.beginPath();
    ctx.arc(f.x, headY + 10, 14, 0, Math.PI * 2);
    ctx.fill();
    
    // Eyes
    ctx.fillStyle = '#fff';
    ctx.fillRect(f.x + f.facing * 4 - 3, headY + 7, 4, 4);
    ctx.fillRect(f.x + f.facing * 10 - 3, headY + 7, 4, 4);
    ctx.fillStyle = '#000';
    ctx.fillRect(f.x + f.facing * 5 - 1, headY + 8, 2, 2);
    ctx.fillRect(f.x + f.facing * 11 - 1, headY + 8, 2, 2);
    
    // Legs
    ctx.fillStyle = flash ? '#fff' : (f.color === '#e63946' ? '#b02030' : '#2d5a7a');
    if (f.crouching) {
      ctx.fillRect(f.x - 15, f.y - 25, 12, 25);
      ctx.fillRect(f.x + 3, f.y - 25, 12, 25);
    } else if (f.state === 'walk') {
      const legAnim = Math.sin(f.animFrame * 0.3) * 10;
      ctx.fillRect(f.x - 12 + legAnim, f.y - 35, 10, 35);
      ctx.fillRect(f.x + 2 - legAnim, f.y - 35, 10, 35);
    } else if (f.state === 'kick') {
      const a = attacks.kick;
      const frame = a.duration - f.stateTimer;
      const ext = frame >= a.startup && frame < a.startup + a.active ? 1 : 0.3;
      // Standing leg
      ctx.fillRect(f.x - f.facing * 5 - 5, f.y - 35, 10, 35);
      // Kicking leg
      ctx.save();
      ctx.fillStyle = '#ff0';
      const kx = f.x + f.facing * 30 * ext;
      ctx.fillRect(kx - 5, f.y - 30, f.facing * 35 * ext, 12);
      ctx.restore();
    } else {
      ctx.fillRect(f.x - 12, f.y - 35, 10, 35);
      ctx.fillRect(f.x + 2, f.y - 35, 10, 35);
    }
    
    // Arms
    ctx.fillStyle = col;
    if (f.state === 'punch') {
      const a = attacks.punch;
      const frame = a.duration - f.stateTimer;
      const ext = frame >= a.startup && frame < a.startup + a.active ? 1 : 0.4;
      // Back arm
      ctx.fillRect(f.x - f.facing * 15 - 4, f.y - h + 25, 8, 25);
      // Punching arm
      ctx.fillStyle = flash ? '#fff' : '#ff0';
      const px = f.x + f.facing * 15;
      ctx.fillRect(px, f.y - h + 30, f.facing * 40 * ext, 10);
      // Fist
      if (ext > 0.5) {
        ctx.fillStyle = '#fff';
        ctx.fillRect(px + f.facing * 40 * ext - 6, f.y - h + 27, 12, 16);
      }
    } else if (f.state === 'special') {
      const wave = Math.sin(f.animFrame * 0.5) * 5;
      ctx.fillRect(f.x + f.facing * 10, f.y - h + 25 + wave, f.facing * 25, 8);
      ctx.fillRect(f.x - f.facing * 10, f.y - h + 30 - wave, -f.facing * 15, 8);
    } else {
      // Idle arms
      const sway = Math.sin(f.animFrame * 0.05) * 2;
      ctx.fillRect(f.x + f.facing * 12, f.y - h + 25, 8, 28 + sway);
      ctx.fillRect(f.x - f.facing * 18, f.y - h + 25, 8, 25 - sway);
    }
    
    // Headband
    ctx.fillStyle = f.color === '#e63946' ? '#fff' : '#e63946';
    ctx.fillRect(f.x - 16, headY + 3, 32, 4);
    // Headband tail
    if (f.facing === 1) {
      const wave = Math.sin(f.animFrame * 0.1) * 3;
      ctx.fillRect(f.x - 16, headY + 3, -12, 3);
      ctx.fillRect(f.x - 28, headY + 3 + wave, -8, 2);
    } else {
      const wave = Math.sin(f.animFrame * 0.1) * 3;
      ctx.fillRect(f.x + 16, headY + 3, 12, 3);
      ctx.fillRect(f.x + 28, headY + 3 + wave, 8, 2);
    }
  }
  
  ctx.restore();
  
  // Draw projectile
  if (f.projectile) {
    const p = f.projectile;
    const glow = Math.sin(Date.now() * 0.02) * 0.3 + 0.7;
    ctx.save();
    ctx.shadowColor = f.color;
    ctx.shadowBlur = 20;
    ctx.fillStyle = f.color;
    ctx.beginPath();
    ctx.ellipse(p.x, p.y, 18, 10, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = `rgba(255,255,255,${glow})`;
    ctx.beginPath();
    ctx.ellipse(p.x, p.y, 10, 6, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
    
    // Trail
    for (let i = 1; i <= 4; i++) {
      ctx.fillStyle = `rgba(${f.color === '#e63946' ? '230,57,70' : '69,123,157'},${0.3 - i*0.06})`;
      ctx.beginPath();
      ctx.ellipse(p.x - p.vx * i * 2, p.y, 14 - i*2, 7 - i, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

// ===== DRAW HUD =====
function drawHUD() {
  // Health bar backgrounds
  const barW = 300, barH = 25, barY = 20;
  
  // P1 bar (left-aligned, depletes from right)
  ctx.fillStyle = '#333';
  ctx.fillRect(30, barY, barW, barH);
  const p1w = (p1.health / p1.maxHealth) * barW;
  const p1grad = ctx.createLinearGradient(30, 0, 30 + barW, 0);
  p1grad.addColorStop(0, '#e63946');
  p1grad.addColorStop(1, '#ff6b6b');
  ctx.fillStyle = p1grad;
  ctx.fillRect(30, barY, p1w, barH);
  
  // P2 bar (right-aligned, depletes from left)
  ctx.fillStyle = '#333';
  ctx.fillRect(W - 30 - barW, barY, barW, barH);
  const p2w = (p2.health / p2.maxHealth) * barW;
  const p2grad = ctx.createLinearGradient(W - 30 - barW, 0, W - 30, 0);
  p2grad.addColorStop(0, '#63b4d6');
  p2grad.addColorStop(1, '#457b9d');
  ctx.fillStyle = p2grad;
  ctx.fillRect(W - 30 - p2w, barY, p2w, barH);
  
  // Bar borders
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.strokeRect(30, barY, barW, barH);
  ctx.strokeRect(W - 30 - barW, barY, barW, barH);
  
  // Names
  ctx.font = 'bold 16px monospace';
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'left';
  ctx.fillText('P1 - ' + p1.name, 30, barY + barH + 18);
  ctx.textAlign = 'right';
  ctx.fillText((aiActive ? 'CPU' : 'P2') + ' - ' + p2.name, W - 30, barY + barH + 18);
  
  // Round indicators
  ctx.textAlign = 'center';
  for (let i = 0; i < 3; i++) {
    ctx.fillStyle = i < p1Wins ? '#ffd700' : '#444';
    ctx.beginPath();
    ctx.arc(340 + i * 20, barY + barH + 14, 6, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = i < p2Wins ? '#ffd700' : '#444';
    ctx.beginPath();
    ctx.arc(W - 340 - i * 20, barY + barH + 14, 6, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Timer / Round
  ctx.font = 'bold 20px monospace';
  ctx.fillStyle = '#ffd700';
  ctx.fillText(`ROUND ${roundNum}`, W/2, barY + 18);
  
  // AI indicator
  if (aiActive) {
    ctx.font = '12px monospace';
    ctx.fillStyle = '#ff0';
    ctx.fillText('CPU ACTIVE', W - 120, barY + barH + 32);
  }
  
  // Combo counters
  [p1, p2].forEach((f, i) => {
    if (comboCounters[i] >= 2 && comboTimers[i] > 0) {
      ctx.font = 'bold 24px monospace';
      ctx.fillStyle = '#ff0';
      ctx.textAlign = 'center';
      const cx = i === 0 ? f.x : f.x;
      ctx.fillText(`${comboCounters[i]} HIT COMBO!`, cx, f.y - 110);
    }
  });
}

// ===== DRAW =====
function drawPixelText(text, x, y, size, color, outline) {
  ctx.font = `bold ${size}px monospace`;
  ctx.textAlign = 'center';
  if (outline) {
    ctx.strokeStyle = '#000';
    ctx.lineWidth = size / 8;
    ctx.strokeText(text, x, y);
  }
  ctx.fillStyle = color;
  ctx.fillText(text, x, y);
}

function drawParticles() {
  particles.forEach(p => {
    const alpha = p.life / p.maxLife;
    ctx.fillStyle = p.color;
    ctx.globalAlpha = alpha;
    ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
  });
  ctx.globalAlpha = 1;
  
  if (hitSpark) {
    const s = hitSpark;
    const progress = 1 - s.timer / 8;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 3 - progress * 2;
    const r = 10 + progress * 30;
    for (let i = 0; i < 6; i++) {
      const a = (i / 6) * Math.PI * 2 + progress * 2;
      ctx.beginPath();
      ctx.moveTo(s.x + Math.cos(a) * r * 0.3, s.y + Math.sin(a) * r * 0.3);
      ctx.lineTo(s.x + Math.cos(a) * r, s.y + Math.sin(a) * r);
      ctx.stroke();
    }
  }
}

// ===== TITLE SCREEN =====
function drawTitle() {
  drawBackground();
  
  // Dark overlay
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(0, 0, W, H);
  
  // Title
  const bounce = Math.sin(Date.now() * 0.003) * 5;
  drawPixelText('STREET', W/2, 140 + bounce, 64, '#e63946', true);
  drawPixelText('BRAWLER', W/2, 210 + bounce, 64, '#457b9d', true);
  
  // Blink
  titleBlink += 0.05;
  if (Math.sin(titleBlink) > 0) {
    drawPixelText('PRESS ENTER TO START', W/2, 320, 24, '#ffd700', true);
  }
  
  // Controls
  ctx.font = '14px monospace';
  ctx.fillStyle = '#aaa';
  ctx.textAlign = 'center';
  ctx.fillText('P1: WASD Move | F Punch | G Kick | H Special', W/2, 390);
  ctx.fillText('P2: Arrows Move | J Punch | K Kick | L Special', W/2, 410);
  ctx.fillText('P2 becomes CPU if idle for 5 seconds', W/2, 440);
  
  drawPixelText('Â© 2026 STREET BRAWLER', W/2, H - 20, 12, '#555', false);
}

// ===== MAIN LOOP =====
let lastTime = 0;
function gameLoop(time) {
  const dt = Math.min(time - lastTime, 32);
  lastTime = time;
  
  ctx.save();
  
  // Screen shake
  if (shakeTimer > 0) {
    shakeTimer--;
    shakeX = (Math.random() - 0.5) * shakeTimer * 1.5;
    shakeY = (Math.random() - 0.5) * shakeTimer * 1.5;
    ctx.translate(shakeX, shakeY);
  }
  
  if (gameState === 'title') {
    drawTitle();
    if (keys['enter']) {
      audioCtx.resume();
      gameState = 'roundIntro';
      roundIntroTimer = 90;
      resetMatch();
      resetFighters();
      playSound('round');
    }
  }
  else if (gameState === 'roundIntro') {
    drawBackground();
    drawFighter(p1);
    drawFighter(p2);
    drawHUD();
    
    roundIntroTimer--;
    
    if (roundIntroTimer > 30) {
      drawPixelText(`ROUND ${roundNum}`, W/2, H/2 - 20, 48, '#ffd700', true);
    } else {
      drawPixelText('FIGHT!', W/2, H/2 - 20, 56, '#e63946', true);
      if (roundIntroTimer === 29) playSound('fight');
    }
    
    if (roundIntroTimer <= 0) gameState = 'fight';
  }
  else if (gameState === 'fight') {
    // Check P2 input for AI toggle
    const p2Keys = ['arrowleft','arrowright','arrowup','arrowdown','j','k','l'];
    if (p2Keys.some(k => keys[k])) p2LastInput = Date.now();
    aiActive = (Date.now() - p2LastInput) > 5000;
    
    // Gather input
    const p1Input = {
      left: keys['a'], right: keys['d'], jump: keys['w'], crouch: keys['s'],
      punch: keys['f'], kick: keys['g'], special: keys['h']
    };
    let p2Input;
    if (aiActive) {
      p2Input = aiControl(p2, p1);
    } else {
      p2Input = {
        left: keys['arrowleft'], right: keys['arrowright'], jump: keys['arrowup'], crouch: keys['arrowdown'],
        punch: keys['j'], kick: keys['k'], special: keys['l']
      };
    }
    
    updateFighter(p1, p1Input, p2, 0);
    updateFighter(p2, p2Input, p1, 1);
    
    // Push apart if overlapping
    const overlap = 50 - Math.abs(p1.x - p2.x);
    if (overlap > 0 && Math.abs(p1.y - p2.y) < 60) {
      const push = overlap / 2;
      if (p1.x < p2.x) { p1.x -= push; p2.x += push; }
      else { p1.x += push; p2.x -= push; }
    }
    
    // Update particles
    particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.vy += 0.2; p.life--; });
    particles = particles.filter(p => p.life > 0);
    if (hitSpark) { hitSpark.timer--; if (hitSpark.timer <= 0) hitSpark = null; }
    
    // Draw
    drawBackground();
    drawFighter(p1);
    drawFighter(p2);
    drawParticles();
    drawHUD();
    
    // Check KO
    if (p1.health <= 0 || p2.health <= 0) {
      gameState = 'ko';
      koTimer = 120;
      winner = p1.health <= 0 ? 2 : 1;
      if (winner === 1) p1Wins++; else p2Wins++;
      playSound('ko');
      shakeTimer = 20;
    }
  }
  else if (gameState === 'ko') {
    drawBackground();
    drawFighter(p1);
    drawFighter(p2);
    drawParticles();
    drawHUD();
    
    // Darken
    ctx.fillStyle = `rgba(0,0,0,${Math.min(0.4, (120-koTimer)/120*0.4)})`;
    ctx.fillRect(0, 0, W, H);
    
    const scale = Math.min(1, (120-koTimer)/15);
    drawPixelText('K.O.', W/2, H/2 - 30, 72 * scale, '#e63946', true);
    
    if (koTimer < 60) {
      drawPixelText(`${winner === 1 ? 'P1' : (aiActive ? 'CPU' : 'P2')} WINS`, W/2, H/2 + 30, 28, '#ffd700', true);
    }
    
    koTimer--;
    if (koTimer <= 0) {
      if (p1Wins >= 2 || p2Wins >= 2) {
        gameState = 'matchEnd';
        koTimer = 180;
      } else {
        roundNum++;
        resetFighters();
        gameState = 'roundIntro';
        roundIntroTimer = 90;
        playSound('round');
      }
    }
  }
  else if (gameState === 'matchEnd') {
    drawBackground();
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, W, H);
    
    const w = p1Wins >= 2 ? 1 : 2;
    drawPixelText(`${w === 1 ? 'PLAYER 1' : (aiActive ? 'CPU' : 'PLAYER 2')} WINS!`, W/2, H/2 - 40, 40, '#ffd700', true);
    drawPixelText('THE MATCH!', W/2, H/2 + 10, 36, '#fff', true);
    
    koTimer--;
    if (koTimer < 100) {
      if (Math.sin(Date.now() * 0.005) > 0) {
        drawPixelText('PRESS ENTER FOR REMATCH', W/2, H/2 + 70, 20, '#aaa', true);
      }
      if (keys['enter']) {
        gameState = 'roundIntro';
        roundIntroTimer = 90;
        resetMatch();
        resetFighters();
        playSound('round');
      }
    }
  }
  
  ctx.restore();
  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);
</script>
</body>
</html>
